---
title: C语言学习1
date: 2019-11-29 14:22:50
tags:
	- c
---





## 变量作用域

* 自动

  块内，普通的变量

* 静态外部链接

  函数定义的变量。在翻译阶段作用域整个翻译单元

* 静态内部链接

  函数外，使用关键字static。仅限于一个翻译单元。（即一个源代码文件和包含的头文件作用域）

* 静态无连接

  块内，使用关键字static



## 关键字

``auto``：被解释为一个自动存储变量的关键字，也就是申明一块临时的变量内存。

``register``：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中

``extern``：引用外部的变量，注意 外部变量不能为static

``static``：函数或者代码块中的变量在函数或者代码块执行第一次初始化分配内存后，就算函数或者代码块执行完毕，该变量也不会被回收 销毁，直到程序结束 static 变量才会被回收

``volatile``：告知计算机，代理（而不是变量所在的程序）可以改变改变量的值

``restruce``：允许编辑器优化代码，适用于指针，表明指针是访问数据对象唯一的方式

``_Atomic(c11)``： 原子对象

## 指针

### 指针声明
```c
void func(int n){
 int *p;
 //左值可修改，右值是常量
 p =  &a;
 // * 是解引用运算符，可以获取到地址的真实值
 int pa = *p;
}
```

```c
// 函数指针
// 含义: p是一个指针参数为void，函数的返回类型为void
void (*p)(void);
```



### 指针常量

**声明指针**

```c
int main()
{
    int const_arr[3] = {0,0,1};

    // 声明一个数据本身不可以修改的常量指针
    const int *p; 
    // 声明一个指针和数据都不可以修改
	// const int * const p = const_arr;
    p = const_arr;
   	// 指针自己可以修改
    p++;
    return 0;
}

```

**多维数组的指针**

```c
int main()
{
    int zippo[4][2] = { {11,12}, {21,22},{31,32}};
 	// 指向多维数组的指针，相当于一个数组 ，数组中每个元素相差8个字节
    // 含义： pz是一个指针，指向一个为2的数组，数据类型为int
    int （*pz)[2];
    
    // 声明一个存储指针的数组
    int *p[2]
        
    // 指向指针的指针
    int **p;

    return 0;
}

```

**多维数组在函数参数中的定义**

```c
// 让编译器知道每个数组间隔8个字节
int sum(int ar[][2],int rows){
    int sum = 0;
    for (int  i = 0; i < rows; i++)
    {
        for (int  j = 0; j < 2; j++)
        {
            sum += ar[i][j];
        }
    }    
    return sum;
}

// 注意顺序不能改变
int sum(int rows,int cols,int ar[rows][cols])
```



<u>3维数组</u>

```c
// 同理3维数组
int zippo[1][2][3] = {  { {1,2,3} ,{4,5,6}   }  };
// 含义 p是一个指针， 指向2，3 数组，数据类型为int
int (*p)[2][3];
```

## I/O

### 字符串声明

```c
// 串联，双引号代表指向指向内容的指针；
char *p  = "how are you" "today";
// 字符串存储在一个静态内存中，此时拷贝到数组中即 字符串有两个副本
char s[50]= "how are you" "today";
```

[^注]: 字符串属于**静态存储类别**，在整个程序的生命周期中都存在





### 缓冲区

```c
#include <stdio.h>
#include <stdlib.h>
int main()
{
    // 初始化缓冲区
    char buff[1024];
    memset(buff, '\0', sizeof(buff));
	// 定义缓冲区的阈值为8
    if (setvbuf(stdout, buff, _IOFBF/* 全缓冲模式 */, 8) != 0) /*失败*/
    {
        printf("failed to set up buffer for input file\n");
    }
    // 输出"12345678"
    fprintf(stdout, "123456789\n");
    sleep(5);
    // 输出剩下的"9\n"
    fflush(stdout);
    system("pause");
    return 0;
}
```





## 补码

4位为例 16 一周期

```c
// -3 = 1101 
// 10000 - 1101 = 0011 
5 - 3 //（0011）
// 3的补码为13
5 + ( 16 - 3 ) 
/*  =（ 10000 - 0011） 
    = （1111 + 1）- 0011
    = （ 1100 + 1）原码取反+1
    = 1101 
*/

```





